Title:  Writeup for Project 4, Summer 2015
 Date:  07/25/15
 Group:	Name		Email				Student ID#
		Jerry Webb	jerryweb@usc.edu	1288504108
		Andrew Lee	lee533@usc.edu		7540910244
		Hao Cui		hcui@usc.edu		1454367516

I. Requirements:
    Part 1: 
    Part 2: Implement fully distributed servers with total ordering algorithm

II. Assumptions:
	No packet lost in network communication. No concern for swap file and TLB error.

III. Design:
    Fully Distributed Airport:

    Fully Distributed Server:
    	Purpose:
		Since single server will have single point of failure and also problem of scalability, a fully distributed server desgin will allow servers to function
		even if some of the servers are down.
		
		Core Theory:
		Every server will process every client's request, it's key to ensure every server process the client request in the same order. From clients point, no 
		siginificant changes from project 3, they'll randomly pick a server, so all servers mean the same to the clients.
		
		Two Major Tasks:
		1-> When a server receives a message from client, it immediately forward that message to all the servers with the original sender's machine id, timestamp
		when sending and mailbox number. 
		
		2-> Achieve Total Ordering Algorithm
			Data:
			a-> A sorted queue of pending request message, ordered from lowest timestamp to highest
			b-> Last Time Recieve Table(Array), storing each server's highest timestamp (only)
			
			Algorithm:
			1) When a server receives message:
				if it's client message
					re-construct the message with sender's machine and mailbox id, forwarded it to all servers
				else 
					send a timestamp update message to other servers, this will make sure all server's timestamp continue to increases
			
			2) Extract the timestamp and machine id from the current message
			
			3)Update the Last Time Received Table with the info from step 2
			
			4)Re-construct the message and append it to sorted pending message list
			
			5)Extract the smallest time stamp from LTR table.
			
			6) Handle the first message of pending list until the timestamp of the message is higher than the smallest timestamp
				(append the last message back to list since it hasn't been handled yet)
			
		Design Details:
			Message Format:
				client message: (after client message appended to the message list it will has the same format as server message)
 					"scIdentifer timestamp requestType requestinfo(varies)"
 					From userprog interface they don't need take care about machineID and mailbox, they will be handled by syscalls.
 				server message:
 					"scIdentifer machineID mailboxID timestamp requestType requestinfo(varies)" 
 				
 				scIdentifer: 0 means client message, 1 means server message
 				timestamp: unsigned int in microseconds
 				The formatting after timestamp is the same as project 3
 				
 			Server structure:
 				We use single threaded server, all the tasks will be performed in main Runserver(), therefore for server as recipient 
 				it's fine to hardcord 0 as mailbox number
		 
		 	Client message:
		 		Only changing the clientReqeust() function, with added in needed machine id and mailbox info when sending message to a 
		 		randomly selected server.
		 	
IV. Implementation:
	+ Files Modified
	[Fully Distributed Airport]
	
	[Fully Distributed Server]
		code/threads/main.cc
		code/threads/system.h
		code/threads/system.cc
		code/userprog/exception.cc
		code/network/serversynch.cc
		code/network/serversynch.h
		        
	+ Files added
	[Fully Distributed Airport]
	
	[Fully Distributed Server]
	None
        
	+ Data Structures added, and the file they were added to.
        (Test files not included)

    
	+ Data Structures modified, and the file they were added to.
        (Test files not included)

    
	+ Functions added and in which file.
        (Test files not included)

    
	+ Functions modified and in which file.
        (Test files not included)



V. Testing:  (For each test case, you must show)
	+ How to test
        nachos -x ../test/<testfile>
            test files:
                matmult
                    basic matmult test
                matmultFork
                    forks two matmult threads
                matmultExec
                    execs two processes which run 'matmult'
                sort
                    basic sort test
            non-standard optional arguments:
                -d <flag>
                    'x' for vm debug statements
                    'z' for syscall debug statements
                    'p' for page initialization debug statements
                -P <FIFO/RAND>
                    chooses the given eviction policy. defaults to FIFO if not present or not valid.
        [NETWORK]
	+ Test Output
        register 4 prints out at the end of every thread:
            <thread name>   The contents of register 4 is <number>
                0 for main thread
                7220 for every matmult thread
                1023 for every sort thread
        [NETWORK]

VI. Discussion:
	+ Experiment expectation
        every matmult returns 7220, every sort returns 1023.
        [NETWORK]ServerLock and ServerCV works as required
	+ Experiment result
        works as intended.
        [NETWORK]ServerLock works conditionly, ServerCV hasn't been tested
	+ Explanation

VIII. Miscellaneous:
- Whatever else you want the grader know about your development.  You can create your own subsections headings here.

	when testing network, please comment out line 71 and line 76-79 in machine.cc
	otherwise the TLB will not be instatniated, the reason is not clear for now