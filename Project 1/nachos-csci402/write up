Title:  Writeup for Project 1, Summer 2015
 Date:  06/10/15
 Group:	Name		Email				SS#
		Jerry Webb	jerryweb@usc.edu	1288504108
		Andrew Lee	lee533@usc.edu		7540910244
		???			???					???


I. Requirements:
    Part 1: Implement locks and condition variables by filling in the empty framework provided. The locks and condion variables must successfully pass the test in the lockTest.cc file. There are 5 tests within that file.
    
    Part 2: Create a multi-threaded airport simulation with the following components:
             - Passengers, who enter the airport with a ticket and luggage and proceed through the simulation until boarding their airplane.
             - Liaisons, who direct passengers to the correct check-in area.
             - Check-in staff, who give passengers boarding passes and process their luggage.
             - Cargo handlers, who transfer processed luggage to their proper airplanes.
             - Screening officers, who check passengers and send them to a security inspector.
             - Security inspectors, who clear passengers checked by the screening officers.
             - A manager, who ensures that all staff are working and allows passengers to board their airplanes at the end of the simulation.

II. Assumptions:
	For the airport simulation:
     - Each airline only has one airplane.
     - Arbitrary upper limit of 6 airlines (requirements state >3).
     - All airlines have the same number of check-in staff.
     - Everyone who keeps track of statistics for the manager does so individually, and the manager polls everyone and adds the results to get the full picture.
     - Passengers are randomly assigned to airlines and given luggage.
     - Passengers will enter a check-in line regardless of whether the staff is on break or not.
     - Each screening officer has a line, and the passenger finds the shortest one.
     - Arbitrary limit of 1-10 screeners and inspectors.
     - The range of passengers for the main simulation is 20 to 100.
     - The range of Airport Liaisons for the main simulaiton is 5 to 7.
     - The range of Check-in Staff for the main simulation is 3 to 5 per airline with a maximum of 15 total.
     - The range of Cargo Handlers is 6 to 10 for the main simulation. 
     - Once initial number of Passengers are created and the Threads are forked at the beginning of the program, no addition passengers can be added to the main simulation.
     - The reason we are mentioning main simulation is due to the special cases for each test.
     - The manager will never go on break during any simulation. 
     - The notes that mentioned that are from class are included in the submission file, however, we will add them to them to this file.
     - When promted to enter a number, the user will enter a positive integer or 0.

III. Design:
- This section is to cover your logic and ideas as to how  you are going to solve the problem presented.  This should include a description of classes, algorithms, etc.

    Part 1: The lock and CV algorithms were given by the professor in class. Locks contain two queues, readyQueue and waitQueue
    - There are only 2 main funtions utilized by the lock class: Acquire and Release. When a lock is acquired by a thread, only that specific thread is able to use the CPU and run its critical section. However, the lock will first disable interrupts (theoritcally things such as I/O signals) and check to see if that thread is not already the lock owner and that if the lock is not already owned by someone else.
    The tests in lockTest thoroughly test the race conditions of each of the locks it genrates. If the thread passes these checks, then it will make himself the owner of the lock 
    - We added a Size function to the list class, which essentially returns the size of the the list. This is allowed all functions that counted or accessed the array and lists of functions throughout the code to be dynamic and avoid looking outside of the bounds of the list.

    Part 2: Each component in the airport simulation has its own class; there is also an "Airport" class for public data: these include variables such as states for liaisons, cargo handlers, etc.. At the start of the simulation, all the liaisons should be set to the Busy state so that the passengers will automatically enter their lines. All the passengers should be forked first, followed by liaisons, then checkin staff nd cargo handlers, then screening and security officers and finally the manager. 

IV. Implementation:
	+ Files Modified - all files are located in the threads directory except for Makefile.common, which is located in the code directory.
        Makefile.common
        list.cc
        list.h
        main.cc
        synch.cc
        synch.h
        threadtest.cc
        system.h
        system.cc

	+ Files added - all files are located in the threads directory.
        airline.cc
        lockTest.cc
        airport.cc
        airline.cc
        cargo.cc
        checkin.cc
        liaison.cc
        manager.cc
        passenger.cc
        screenofficer.cc
        securityinspector.cc

        airport.h
        passenger.h
        airportobjects.h
        airport.h
        airline.h
        cargo.h
        checkin.h
        liaison.h
        screenofficer.h
        securityinspector.h
        manager.h

	+ Data Structures added, and the file they were added to.
        Classes: 
            Passenger - added to passenger.h 
            Liaison - added to liaison.h
            Airport - added to airport.h
            Airline - added to airline.h
            Cargo - added to cargo.h
            Checkin - added to checkin.h
            Manager - added to manager.h
            ScreenOfficer - added to screenofficer.h
            SecurityInspector -add to securityinspector.h

        Structs:
            Luggage - added to airportobjects.h
            Ticket - added to airportobjects.h
            BoardingPass - added to airportobjects.h

        Enums:
            LiasionState - added to airportobjects.h
            CheckinState - added to airportobjects.h
            CargoState - added to airportobjects.h
            AirlineState -added to airportobjects.h

        Arrays and Lists:
            - In manager.h:   
                List** airlineLuggage  
                int* liaisonBaggageCount           
                int* cargoHandlersBaggageWeight
                int* checkinBaggageWeight          
                int* cargoHandlersBaggageCount
                int* liaisonPassengerCount 
                int* checkinPassengerCount
                int* securityInspectorPassengerCount
            - In cargo.h:
                int* luggage
                int* weight
            - In liaison.h
                int* passengers
                int* luggageCount
                int* totalLuggageWeight
            - In airport.h
                bool* RequestingLiaisonData
                bool* RequestingCargoData
                bool* RequestingCheckinData
                Airline** airlines
                List* airlineState[3]
                List* passengerList
                List* liaisonQueues[7]
                List* liaisonList
                List* conveyor
                List* cargoHandlerList 
                Lock* liaisonManagerLock
                Lock* liaisonLineLock
                Lock* liaisonLock[7]
                CargoState cargoState[10] 
                List** aircraft
                int* clearPassengerCount 
                List* securityInspectorList
                List** screenQueues
                List** securityQueues
                List** returnQueues.
                List* screeningOfficerList
                LiaisonState liaisonState[7]
                bool* finalCheckin
                List** checkinQueues 
                List* checkInStaffList
                CheckinState* checkinState
            
            Locks
             - In airport.h    
                Lock** airlineLock
                Lock** checkinLineLock
                Lock** checkinLock
                Lock* checkinManagerLock 
                Lock* conveyorLock             
                Lock* CargoHandlerManagerLock  
                Lock* cargoLock[10]
                Lock* cargoDataLock[10]
                Lock** screenLocks
                Lock* screenQueuesLock 
                Lock** securityLocks 
                Lock* securityQueuesLock 
                Lock* updateClearCount

            Conditions
             - In airport.h
                Condition* liaisonLineCV[7]
                Condition* liaisonManagerCV
                Condition* liaisonCV[7]
                Condition** checkinLineCV
                Condition** checkinCV
                Condition** checkinBreakCV
                Condition* checkinManagerCV
                Condition* cargoCV             
                Condition* cargoDataCV[10] 
                Condition* cargoManagerCV[10]
                Condition** inspectorWaitPassengerCV
                Condition** passengerWaitInspectorCV
                Condition** passengerWaitOfficerCV    
                Condition** officerWaitPassengerCV
                Condition** inspectorWaitRePassengerCV
                Condition** rePassengerWaitInspectorCV
                Condition** inspectorWaitQuestioningCV  

	+ Data Structures modified, and the file they were added to.
			class Lock		-- in file synch.cc/synch.h
			{
				//. Modified fields.
                List* waitQueue
                List* readyQueue
                Thread* lockOwner
                enum State {FREE, BUSY};
                State lockState;
			}

            class Condition -- in file synch.cc/synch.h
            {
                Lock* waitLock;
                List* waitList;
            }

	+ Functions added and in which file.
        - In Passenger.cc/Passenger.h
            Passenger(int ID, List* bags, Ticket T, Airport* A)
            Passenger(int ID, Ticket t, int airlineCode, Airport* a)
            Passenger(int ID, Ticket t)
            Passenger(int ID, Airport* a)
            Passenger(int ID)
            Passenger()
            Passenger(int ID,int qIndex,Airport* AIRPORT)
            Passenger(int ID,int qIndex,Airport* AIRPORT,int airlineCode,SecurityInspector** INSPECTORLIST)
            Passenger(Airport* AIRPORT)
            ~Passenger();
            int findShortestLine(List** list, bool CISline)
            void findShortestLiaisonLine()
            void CheckIn()
            Ticket getTicket()
            List* getLuggage()
            int getID()
            void Screening()
            void Inspecting()
            void SetQueueIndex(int qIndex)
            void SetSecurityPass(bool pnp)
            bool GetSecurityPass()
            BoardingPass GetBoardingPass()
            void SetBoardingPass(BoardingPass BP)
            int GetAirline()
            void SetAirline(int airline_)

        - In airport.cc/airport.h
            Airport()
            Airport(int airlines, int passengers, int liaisons, int checkins, int security, int cargo)
            ~Airport()

        - In cargo.cc/cargo.h
            Cargo(int id, Airport* airport)
            ~Cargo()
            void StartCargo()
            int getID()
            int getLuggage(int airline)
            int getWeight(int airline)

        - In checkin.cc/checkin.h
            CheckIn(int airline, int id, Airport* airport)
            ~CheckIn()
            Passenger* FindPassenger(int execLine)
            void StartCheckInStaff()
            int getID()
            int getAirline()
            int getPassengers()
            int getLuggageCount()
            int getLuggageWeight()

        - In liaison.cc/liaison.h
            Liaison(int ID, Airport* airport)
            ~Liaison()
            void DirectPassengers()
            int getID()
            Passenger* CheckForPassengers()
            int getPassengers(int airline)
            int getLuggageCount(int airline)
            int getLuggageWeight(int airline)   

        - In manager.cc/manager.h
            Manager(Airport* airport)
            ~Manager()
            void MakeRounds()
            void LiaisonDataRequest(Liaison *L)
            void CheckinDataReuqest(CheckIn *C)
            void CargoRequest(Cargo *CH)
            void SecurityDataRequest()

        - In main.cc/threadtest.cc
            void MailTest(int networkID)
            void TestSuite()
            void ManagerTest()
            void LiaisonTest()
            void PassengerFindsShortestLiaisonLine()
            void PassengerFindsCorrectCISLine()
            void CheckInTest()
            void CargoTest()
            void ScreenTest()
            void InspectTest()
            void MTest()

        - In synch.cc/synch.h
            bool isHeldByCurrentThread()

    //Need to finish adding functions to threadtest
        - In threadtest.cc
            void StartFindShortestLiaisonLine(int arg)
            void StartFindCorrectCISLine(int arg)
            void StartLiaisonTest(int arg)
            void StartLiaisonThread(int arg)
            void StartCargo(int arg)
            void StartManager(int arg)
            void StartCheckInTest(int arg)
            void StartCheckInStaff(int arg)
            void StartScreening(int arg)
            void StartScreeningTest(int arg)
            void StartInspecting(int arg)
            void StartInspectingTest(int arg)
            void StartupOutput(Airport* airport)

	+ Functions modified and in which file.
            class Lock      -- in file synch.cc/synch.h 
            {
                void Acquire()
                void Release()
            }

            class Condition -- in file synch.cc/synch.h
            {
                void Wait(Lock *conditionLock)
                void Signal(Lock *conditionLock)
                void Broadcast(Lock *conditionLock)
            }

            int main        -- in file main.cc
            {
                main(int argc, char **argv)
            }

V. Testing:  (For each test case, you must show)
	+ How to test
        All tests are run from the code/threads folder, using the command "nachos".
        The arguments that correspond with each test are:
         "-T":        Lock and CV test code.
         "-findL":    Passenger selects the shortest line for the airport liaison.
         "-liaison":  Passenger is directed by the Liaison to the correct airline counters.
         "-findCIS":  Economy class passengers enter the shortest line while Executive class passengers enter their correct line.
         "-checkin":  Executive class passengers are given priority over the economy class passengers at the check-in kiosks.
         "-screen":   Screening officer chooses an available security inspector each time a passenger comes in.
         "-cargo":    Cargo handlers choose bags from the conveyor system each time and go on a break if there are no bags.
         "-screen":   Handing over of the hand luggage by the passenger to the screening officer.
         "-inspect":  Passenger returns to the same security inspector after further questioning.
         "-mtest":    Baggage weights of all the passengers of a particular airline should match the weights of the bags reported by the cargo handlers.
         "-inspect":  Handing over of boarding pass by the passenger to the security inspector.
         "-manager":  Hardcoded airport simulation.
         "-airport":  Full airport simulation.
         "-menu":     Menu allowing choice between all tests.
    + Test Output
- Describe the testing output. You don't have to dump all the output info. Just make sure your description can exactly reflect your output.
        

VI. Discussion:
	+ Experiment expectation.  (What you hope will happen.)
        For PassengerFindsShortestLiaisonLine Test:
            This is the test to show that the passenger chooses the correct line.
            Liaison Queues 0 through 5 are filled with dummy sizes all greater
            than queue 6 to demonstrate passenger finding shortest queue (size 0)
            Adds dummy passengers into the liaison queues:
               line 0: 6
               line 1: 5
               line 2: 4
               line 3: 3
               line 4: 2
               line 5: 1
               line 6: 0
            Sets liaison to busy
              Initializes 1 passenger (id 0) and runs it.
              Intended result:
               Passenger 0 will go to line 6 (length 0).
        
        For LiaisonTest Test
           Adds 1 passengers into liaison 0's queue:
            id 0, ticket.airline 2
           Initializes 1 Liaison thread (id 0) and runs it.
           Intended result:
            The Liaison will direct the passenger to airline 2.

        For CheckInTest
           Adds 3 passengers into the airline 0 check-in queue:
            id 0, executive (line 0)
            id 1, economy (line 1)
            id 2, economy (line 1)
           Initializes 1 CIS thread (id 1; airline 0) and runs it.
           Intended result:
            The CIS will choose to help the executive passenger.
            The economy line will stay at length 2.
	
        For CargoTest
           Adds 7 bags onto the conveyor:
            airline 0, weight 30
            airline 1, weight 42
            airline 2, weight 54
            airline 0, weight 30
            airline 1, weight 45
            airline 0, weight 45
            airline 1, weight 60
           Initializes 6 cargo (0-5) threads and runs them.
           Intended result:
            The bags will be added to the proper airplane in the
             order in which they were added to the conveyor.
             After all bags are finished, the cargo handlers
             will all go on break.

        For AirportSim
            This should simulate the entire airport running from start to finish as mentioned in the guidlines. 

    + Experiment result.  (What actually happens.)
        For PassengerFindsShortestLiaisonLine Test, LiaisonTest Test, CheckInTest, and CargoTest all generate the correct output that is listed above in the experiment expectation.

        A final boarding call and confirmation to the manager that all passengers have boarded would eliminate this problem because the final call would only allow the manager to gather data from all parties one last time before displaying the data at the end. Instead the simulation will run in an infinite loop, as the manager will keep asking for data. 
        


	+ Explanation
		- Explain your experiment result.
            As mentioned in the previous section, our simulation will not completely finish due to the fact that the two portions (screening officer and passenger interaction along with manager screeing officer interaction and once the passenger is directed to the gate) are not connect. All of these funtions, however, do work seperately within different tests. All functions not concerning the security officer and screening officer will work in one simulation including the collection of data by the manager from checkin staff, liaisons, and cargo handlers. However due to the inability of the passengers to fully board the plane, the output will not show the correct values. This is due to this specific loop:
                for(int i = 0; i < airport->numAirlines; i++){ 
                    liaisonPassengerCount[i] = 0;
                    liaisonBaggageCount[i] = 0;
                }

                and

                for(int i = 0; i < airport->numAirlines; i++){       
                    checkinPassengerCount[i] = 0;
                    checkinBaggageWeight[i] = 0;
                }
                '
                and
                
                for(int i = 0; i < airport->numAirlines; i++){
                    cargoHandlersBaggageCount[i] = 0;
                    cargoHandlersBaggageWeight[i] = 0;
                }.

            These functions prevent double and multi-counting of data when the manager requests data from each thread. A final boarding call and confirmation to the manager that all passengers have boarded would eliminate this problem because the final call would only allow the manager to gather data from all parties one last time before displaying the data at the end. Instead the simulation will run in an infinite loop, as the manager will keep asking for data. 


VIII. Miscellaneous:
- Whatever else you want the grader know about your development.  You can create your own subsections headings here.
The Putty terminal locked us out when we were testing our simulation due to us exceeding the process limit. We were sent an email by ITS explaining what had happed:
Our computing policies were instituted to help maximize the resources
available to our user community.  We expect you to act responsibly and
with consideration to others.  Please do not run more than 20 processes
at one time on the SCF timesharing hosts.  You may want to check for and
kill old processes if you are disconnected, using
        /usr/ucb/ps aux | grep jerryweb   ; kill PID
as you may have processes from several old login sessions.

As outlined in our policies, this message registers a warning.
Additional abuses may result in harsher penalties.

For the complete list of policies, go to:

  http://www.usc.edu/its/policies

Thank you for your cooperation. This message was generated automatically.

  Information Technology Services,  Information Infrastructure Core
  Univ of Southern California, consult@usc.edu, 213(740)5555, 90089-0251



USER       PID %CPU %MEM   SZ  RSS TT       S    START  TIME COMMAND
jerryweb 10755  0.0  0.013488 6792 ?        S 19:57:53  0:53 /usr/lsd/openssh/default/sbin/sshd -R
jerryweb 10757  0.0  0.0 3816 3384 pts/29   S 19:57:53  0:00 -tcsh
jerryweb 11570  0.0  0.0 6168 4824 pts/29   T 19:58:24  0:02 nachos -manager
jerryweb 16990  0.0  0.0 6168 4824 pts/29   T 20:09:16  0:01 nachos -manager
jerryweb 18008  0.0  0.0 6168 4824 pts/29   T 20:14:12  0:02 nachos -manager -rs 7
jerryweb 18105  0.0  0.0 6168 4792 pts/29   T 20:14:46  0:01 nachos -manager
jerryweb 18232  0.0  0.0 6168 4792 pts/29   T 20:15:25  0:01 nachos -manager
jerryweb 18962  0.0  0.0 6168 4824 pts/29   T 20:18:07  0:01 nachos -manager
jerryweb 19213  0.0  0.0 6168 4792 pts/29   T 20:19:12  0:01 nachos -manager
jerryweb 20581  0.0  0.0 6168 4792 pts/29   T 20:24:37  0:01 nachos -manager
jerryweb 21786  0.0  0.0 6168 4824 pts/29   T 20:30:07  0:01 nachos -manager
jerryweb 21800  0.0  0.0 6168 4824 pts/29   T 20:30:12  0:03 nachos -manager -rs 0
jerryweb 21816  0.0  0.0 6168 4824 pts/29   T 20:30:19  0:02 nachos -manager -rs 1
jerryweb 21847  0.0  0.0 6168 4824 pts/29   T 20:30:33  0:00 nachos -manager -rs 100
jerryweb 21862  0.0  0.0 6168 4824 pts/29   T 20:30:39  0:00 nachos -manager -rs 10
jerryweb 22004  0.0  0.0 6168 4824 pts/29   T 20:31:33  0:00 nachos -manager -rs 5
jerryweb 22009  0.0  0.0 6168 4824 pts/29   T 20:31:37  0:00 nachos -manager -rs 2
jerryweb 22019  0.0  0.0 6168 4824 pts/29   T 20:31:40  0:00 nachos -manager -rs 20
jerryweb 23271  0.0  0.0 6168 4824 pts/29   T 20:37:37  0:00 nachos -manager -rs 20
jerryweb 23583  0.0  0.0 6168 4824 pts/29   T 20:38:30  0:00 nachos -manager
jerryweb 24433  0.0  0.0 6168 4840 pts/29   T 20:42:51  0:00 nachos -manager
jerryweb 27814  0.0  0.0 6168 4824 pts/29   T 20:58:20  0:01 nachos -manager -rs 0
jerryweb 27907  0.0  0.0 6168 4824 pts/29   T 20:58:45  0:01 nachos -manager -rs 1
jerryweb 27929  0.0  0.0 6168 4824 pts/29   T 20:58:54  0:01 nachos -manager -rs 5
jerryweb 27940  0.0  0.0 6168 4824 pts/29   T 20:58:58  0:00 nachos -manager -rs 50
jerryweb 28216  0.0  0.0 6168 4840 pts/29   T 21:00:14  0:00 nachos -manager
jerryweb 28227  0.0  0.0 6168 4840 pts/29   T 21:00:19  0:00 nachos -manager -0
jerryweb 28274  0.0  0.0 6168 4840 pts/29   T 21:00:35  0:01 nachos -manager -rs 0
jerryweb 28315  0.0  0.0 6168 4840 pts/29   T 21:00:52  0:00 nachos -manager -rs 1
jerryweb 28326  0.0  0.0 6168 4840 pts/29   T 21:00:56  0:01 nachos -manager -rs 0
jerryweb 28362  0.0  0.0 6168 4840 pts/29   T 21:01:11  0:00 nachos -manager -rs 1
jerryweb 28373  0.0  0.0 6168 4840 pts/29   T 21:01:14  0:00 nachos -manager -rs 5
jerryweb 28387  0.0  0.0 6168 4840 pts/29   T 21:01:19  0:01 nachos -manager -rs 9
jerryweb 28395  0.0  0.0 6168 4840 pts/29   T 21:01:23  0:00 nachos -manager -rs 11
jerryweb 28408  0.0  0.0 6168 4840 pts/29   T 21:01:25  0:01 nachos -manager -rs 100
jerryweb 28472  0.0  0.0 6168 4840 pts/29   T 21:01:41  0:01 nachos -manager -rs 2
jerryweb 28510  0.0  0.0 6168 4840 pts/29   T 21:01:44  0:00 nachos -manager -rs 4
jerryweb 28521  0.0  0.0 6168 4840 pts/29   T 21:01:49  0:00 nachos -manager -rs 6
jerryweb 28526  0.0  0.0 6168 4840 pts/29   T 21:01:52  0:00 nachos -manager -rs 7
jerryweb 28567  0.0  0.0 6168 4840 pts/29   T 21:01:54  0:00 nachos -manager -rs 8
jerryweb 28581  0.0  0.0 6168 4840 pts/29   T 21:01:59  0:00 nachos -manager -rs 13
jerryweb 28592  0.0  0.0 6168 4840 pts/29   T 21:02:02  0:00 nachos -manager -rs 12
jerryweb 28634  0.0  0.0 6168 4840 pts/29   T 21:02:05  0:00 nachos -manager -rs 14
jerryweb 28644  0.0  0.0 6168 4840 pts/29   T 21:02:08  0:01 nachos -manager -rs 15
jerryweb 28699  0.0  0.0 6168 4840 pts/29   T 21:02:20  0:00 nachos -manager -rs 16
jerryweb 28724  0.0  0.0 6168 4840 pts/29   T 21:02:24  0:00 nachos -manager -rs 24
jerryweb 28781  0.0  0.0 6168 4840 pts/29   T 21:02:38  0:01 nachos -manager -rs 27
jerryweb 29277  0.0  0.013424 6712 ?        S 21:04:43  0:00 /usr/lsd/openssh/default/sbin/sshd -R
jerryweb 29281  0.0  0.0 3296 2512 ?        S 21:04:43  0:00 tcsh -c /usr/lsd/openssh/default/libexec/sftp-server -l QUIET
jerryweb 29283  0.0  0.0 7392 3592 ?        S 21:04:43  0:00 /usr/lsd/openssh/default/libexec/sftp-server -l QUIET


Notes from class:

6.1.15
    New Solution - Use a lock
    Lock milklock;
        algorithm
        main()
            milklock.Acquire();    //atomic
            if(nomilk){         //critical secition 
                buy milk;
            }                   //critical secition 
            milklock.release(); //atomic 




Lock Implementation 
Rule: Aquire & Release – atomic
    Use interrupt disabling 
    Pattern
      Disable interrupts 
        carryout tasks
      restore interrupts




Nachos Interrupt Class
    Already exists 
    Interrupt object

Disable: IntStatus old = interrupt->SetLevel(IntOff); 

Restore: interrupt->SetLevel(old);

//myself represents the thread in the CPU   

No Busy Waiting 
    Approach: Sleep/wakeup
    Sleep: A thread "state" where it cannot gain access to the CPU 
        * on its own
        * or by the scheduler
    
    Wakeup: the event a thread was waiting for has occured 

    sleep Implementation:
        for a thread to gain CPU access
            * it must be in the ready queue
            * in the ready State

    Goal #1: Removing a thread from the ready queue
            currentThread->Sleep();     //CurrentThread is a pointer to the thread in the CPU

    Goal #2: Use a seperate queue
            * wait queue                
            * $pecific to each lock
            Add a waitqueue to lock class
            Be sure to add the currentThread to the waitqueue BEFORE currentThread->Sleep()

    Wakeup Implementation 
    1. Wakeup 1 sleepy thread - if one exists 
    2. Give them ownership of the lock 
    3. Put them in Ready Queue in Ready State
        scheduler->ReadyToRun( /*thread pointer*/); 
    Locks have 2 states
        * FREE - available 
        * BUSY - not available

Part 1 of Project 1
    void Lock::Aquire(){
        disable interrupts
        if(/*I'm the lockowner */){
            //not a problem 
            restore intterupts 
            return; 
        }

        if(/*lock is available*/){
            //I can have the lock
            make lock BUSY 
            make myself lock owner 
        }   

        else{//lock not available 
            //put myself to sleep 
            add myself to lock wait queue //the wait queue is a queue of thread pointers 
            currentThread->Sleep();
        }

        restore interrupts
    }

    //can use the List class in Nachos 

    void Lock::Release(){
        Disable interrupts
        if(/*I'm not the lock owner*/){
            print an error message 
            restore interrupts
            return;
        }

        if(/*is any thread waiting */){
            * Rmove 1 thread from wait Queue 
            * call scheduler-ReadyToRun();
            * make them the lock owner
        }

        else{
            make lock FREE
            remove lock ownership // set lock thread pointer back to null
        }

        retore interrupts
    }

    

    Lock* l;                    
        .                           |   .
        .                           |   .
        l->Aquire();                |   doit(); //this has *l->Aquire ..... l->realease 
            doit();                 |





    Solving Sequencing 
        Semaphores 
        Condition varibles  // there is a condition class in Nachos similar to the lock class

    Condition Varibles
        Dont have a state like locks
        Have 3 operations 
        Wait: put myself to sleep waiting on some condition
        Signal: wakeup 1 sleeping thread //if there is a sleeping thread
        Broadcast: wakeup all sleeping threads


    void Condition::Wait(lock* Lock){
        disable interrupts
        if(lock==NULL){
            print message
            restore intterupts
            return;
        }

        if(waitingLock == NULL){//frist thread to call wait
            // waitingLock is for lock* tracking 
            waitingLock = lock;
            the lock used with this condition varible       
        }

        if(waitingLock != lock){//lock passed in doesnt match the lock already used
            print error message 
            restore interrupts
            return;
        }

        lock->Release(); // exit the critical section so 
        add myself to condition varible wait queue and go to sleep
        lock->Aquire();
        restore interrupts
        return;
    }


    myLock->Aquire();
        .
        .
        if(/* I can't proceed*/){
            myCV->Wait(myLock); //myCV is my condition varible 
            //don't wait in the critical section

        }   
        .
        .
        myLock->Release();


    void Condition::Signal(lock* Lock){
        disable interrupts
        if(/*No waiting threads*/){
            restore interrupts
            return;
        }

        if(waitingLock != lock){
            print error
            restore interrupts
            return;
        }

        //wakeup 1 waiting thread
        remove 1 thread from the condition varible wait queue
        scheduler->ReadyToRun

        if(/*no more waiting threads*/){
        waitingLock = NULL;
        }

        restore interrupts
    }


    void Condition::Broadcast(lock* Lock){
        while(/*there ARE waiting threads*/){
            Signal(lock);
        }
    }


    Monitors 
    * surround a critical section with a monitor 
    * Monitors have 3 parts 
        - 1 lock
        - 1 or more condition varibles
        - monitor varibles 
            * data we use to make Sequencing desicions 

    Monitor Form
    Aquire the monitor lock
    use/modify varibles to make Sequencing desicions
    release monitor lock


    Grocery Store Checkout
    - multiple cashiers 
    - each has their own line
    - customer will pick the shortest line 
        * person at the cashier is in line
        
        Use a Monitor
            Lock* lineLock;
            //Lock* lineLock = new Lock("___"); // can do this in Nachoes
            //1 or more - cashier busy-only 1 inline
            //0 - casheir available
            // you need as many locks as you have cashiers
            Condition* lineCV[5]; // Condition class does not have a default constructor 
            int lineCount[5]; //should initialize all these to zero

            Customer
                lineLock->Aquire();
                int ShortCount = LineCount[0];
                int myLine = 0;
                for(int i != 0,i<5;i++){
                    if(LineCount[i] < ShortCount){
                        ShortCount = LineCount[i];
                        myLine = i;
                    }
                }
                //Found a line 
                if(ShortCount > 0){
                    lineCV[myLine]->Wait(LineLock);
                }
                //my turn
                LineLock->Release();
                //Begin Cashier itneraction critical section


            Cashier //have thier own variable called myLine, which is the line they are assigned to 
                while(true){
                    LineLock->Aquire();
                    if(LineCount[myLine] > 0){
                        lineCV[myLine]->Signal(LineLock);
                    }
                    LineLock->Release();
                    //Begin Cashier interaction critical section
                }

6.3.15

There will be a nachos synchronization problem for the airport. We will have to implement a new thread into the code


nachos-csci402
    |
    |
   code - 1st time- gmake
   * in the code folder there should be files: threads, test, vm, filesys, network, and userprog
   for threads: project 1 is in this... compile and run 

   threads, vm, filesys, network, and userprog are nachos and the test is nachos user programs


2 ticket-typs: economy and executive

airline 1: each airline has 5 queue (example) and one executive queue, however, executive queue has priority. Each queue
            has a count 
            can make an array of size 6 for the monitor variable where the length of the line is in the corresponding each queue
            and set the executive queue to index 0
            the economy queues and the executive queue have seperate locks (2 locks in total, this is one option)
            * more locks are good if it doesn't create a race condition 

airline 2

airline 3


Passenger
    LineLock->Aquire();
        int myLine = 0;
        int shortCount = LineCount[0];
        for (){

        }

        if(shortCount > 0){
            LineCV[myLine]->Wait(LineLock)
        }

    LineLock->Release();
    //go up to check-in staff
    cisLock[myLine]->Aquire();
    //write ticket info to a cis specific location 
    cisCV[myLine]->Signal(  );

    cisCV[myLine]->Wait(    );

    //read seat # 
    cisCV[myLine]->Signal(  );
    cisLock[myLine]->Release();



********Wait and Signal calls MUST STAGGER (wait and signal must alternate)********

Check-In Staff
    while(true){
        if anyone in executive queue
            check them in
    }

    else 
        do my economy queue

    //The is the start of the 1st critical section 
    LineLock->Aquire();
        if(LineCount[myLine] > 0){
            LineCV[myLine]->Signal(LineLock); //signaling doesn't give it access to the CPU right away
        }

        //could be a context switch here
        cisLock[myLine]->Aquire(); //this must go here before you call wait in the 2nd critical section 
    LineLock->Release();
    //end of first critical section

    //beginning of 2nd critical sectoin
    //Wait for passenger ticket info
    cisLock[myLine]->Wait(  );
    //check in passenger 
    -Give boarding pass-seat # //this info is transeferd to the passenger (can be part of the ticket info struct we create
    cisCV[myLine]->Signal(  );
    cisCV[myLine]->Wait(    ); //must wait for the passenger to read the data
    //end of 2nd critical section 

    cisLock[myLine]->Release();



Condition::Wait(Lock* lock){


    *lock->Release();
    currentThread->Sleep();
    lock->Aquire(); //Goes to sleep waiting on lock 
        |
        |
        |
    //give ticket info to Check-in Staff
}



void doit(void* myFunc){ // this is an example of function pointer passing 
    myFunc();
}


for(int i=0; i < maxPassengers; i++){
    Thread *t = new Thread("______");
        t ->Fork(passenger/*fucnction pointer*/,i); //don't put parrentheses after the passenger function call 
                                                //i is also the line the employee is assinged as well as the employee's ID when you are instantiating the emplyees 
}


void passenger(int myNumber){
    Ticket myTicket

}



nachos -rs 100 -T -P2//100 is given to Srand 
    //adding -rs will allow for context switiching preemptively, if you you get an error on a given random seed value, use the same value to fix the error
    //test multiple values 
    preemptive 

    Part 1: Test suite




main.cc
int main(   ){
    for(    ){//iterates over all command line args
        if( -rs )

        else if(/*arg is -T*/){
            TestSuite();
        }   
    }
}


to test the that the passenger gets into the shortest line; all you need is a passenger thread and hardcoded line count values 

**** for the system test, DO NOT PROMPT THE USER FOR THE NUMBER OF THREADS

for each test, terminate nachos once the test is finished 


Semaphores
    1 mechanism for handling ...
    have an int value 
    0 -> positive # // no negative numbers 
    two operations 
        up      v //increments the value of the semaphore by 1; if some thread waiting-wake1up
        Down    p //decrements semaphore value if > 0; if value < 1, go to sleep first


Mutual Exclusion 
    use a binary semaphore
        initial value is 1
    To enter critical section
        do a Down 
    To exit critical section
        do an Up



many threads all doing the same thing
    Whil(true){
        sem.Down();
            |
            |
        sem.Up();
            |
            |

    }


synchronization
    - any initial value
    - Down or Up


Soda Machine
    capacity 10
    student - take 1 Soda
    SodaGal - add 1 Soda

    -When must SodaGal wait?
    1 - machine full    empty - start @ 10
    Student 
    -machine empty
    2 full -starts @ 10
    3 mutex


SodaGal
    while(true){
        * empty.Down();
        mutex.Down();
        //add 1 soda
        mutex.Up();
        * full.Up();
    }

Student
    * full.Down();
    mutex.Down();
        take 1 soad
    mutex.Up();
    * empty.Up();

6.8.15

int LiaisonState[];     //array of states for the LiaisonState
    //2 values: busy, free
    //initialize the array so that all the liaisons are busy 
    //this will make sure that the passengers wait for the liaison to start his thread even if the passengers
    //are initialized first 

LineLock
LineCV[]
LineCount[]


Passenger
    int myLine
    LineLock->Aquire();
    for(){
        //find a line
    }
    //found my line
    if(LiaisonState[myLine] == BUSY){   //if(LineCount[myLine] > 0)
        //Wait in line
        lineCount[myLine]++;
        LineCV[myLine]->Wait(   );
        //lineCount[myLine]--;          //This is if you are not using states for the liaison to check if for the line in the above if statement 
    }
    
    LineLock->Release();


/*you will need a state variable for things that can go on break*/

Liaison 
    LineLock->Aquire();
    //no advantage to setting the liaison to free for the first iteration
    if(lineCount[myLine] > 0){
        LineCV[myLine]->Signal();
        lineCount[myLine]--;            //this does not produce a race condition because he is set to busy in the same Critical Section
        LiaisonState[myLine] = BUSY;
    }

    else{
        LiaisonState[myLine] = FREE;
    }

    liaisonLock[myLine]->Aquire();
    LineLock->Release();
    LiaisonCV[myLine]->Wait(    );


int cisState[];
    -   BUSY
    -   FREE
    -   onBREAK

Check-in staff                      //start everyone off in the BUSY state
    while(true){                    //same with cargo handlers
        cisLineLock->Aquire();
        bool havePassenger = false;
        //check execline length
        //if no exec passengers, check my econ line
        //Theese can be handled by bool havePassenger = false;
        if(!havePassenger){     //go on break
            cisState[myLine] = onBREAK;
            cisOnBreakCV[myLine]->Wait( );
            cisState[myLine] =  BUSY;
            cisLineLock->Release();
            //cisLineCV[myLine]->Signal(    );
            continue;
        }

        //if all checkin staff are asleep and there is a passenger in the executive line, then do a broadcast

        cisCV[myLine]->Aquire();
        cisLineLock->Release();




        cisCV[myLine]->Release();
    }



    CIS 
    -each have their own line 


    Cargo Handlers                              -starting # of C.H.
        -one line per airline
        -Broadcast from mannagers to wake them up
        -on break

        if bagCount > 0 && all C.H. on break    -chonBreakCount
            then Broadcast

        chBreakCV           //can't have one CV for break; need to have an array 

// Manager NEVER GOES TO SLEEP 
Airport Manager
    while(true){
        lock1->Aquire();
            //do task
        lock1->Release();

        lock2->Aquire();
            //do task
        lock2->Release();
            .
            .
            .
        for(int i = 0; i < 100 (or 1000); i++){ //this makes the manager give up the CPU otherwise he would hog the CPU
            currentThread->Yield();
        }
    }









int passSecurtiy[maxPassengers];    //only shared between the Screeing Officer and Security Inspector

Screening Officer
    
    SO[myLine]->Aquire();
        //Generate random PASS/FAIL
        // -get passenger's index number (index in the array of the total number of passengers) - myPassenger
        //find a line for this passenger w/SI
            // -find shortest line
            // -give that line # to passenger
            // -give PASS/FAIL to the proper Security Inspector
        passSecurtiy[myPassenger] = PASS/FAIL;


    soCV[myLine]->Wait( );


Passenger
    while(true){
        //start of S.I. code
        didIPass = SIPassFail[siLine];  
        siLock[siLine]->Release();
        SO[soLine]->Aquire();
            //give bag to S.O.
        soCV[soLine]->Wait( );

        //passenger waits for PASS/FAIL
                            
            if(!didIPass){                  //This statement is not with the Security Inspector; outside of S.I. CV
                for(){
                    currentThread->Yield();
                }
                continue;
            }

            else{
                break;
            }

        siCV[siLine]->Wait( );
    }



Screening Inspector 

    siLineLock->Aquire();
            .
            .
            .
        getPassenger #
    //passenger fails
        -tell them SIPassFail[myLine] = PASS/FAIL;
        -set their PASS/FAIL to PASS



Passenger version 2
    bool didIFail;
    while(true){
        SiLock[mySi]->Aquire();
            //give passenger #
            siCV[mySi]->Signal( );
            siCV[mySi]->Wait(   );

            didIPass = SIPassFail[mySi];
            siCV[mySi]->Signal( );
        siLock[mySi]->Release();
        if(!didIPass){ continue; }

        else{ break; }
    }



Screening Inspector version 2

    siLock[myLine]->Aquire();
    siLineLock->Release();
        siCV[myLine]->Wait( );          //wait for passengr #
        //Generate PASS/FAIL
        passSecurtiy[passNow] = PASS/FAIL;
        SIPassFail[myLine] = PASS/FAIL;

        siCV[myLine]->Signal(   );
        siCV[myLine]->Wait(     );      //wait for passenger to read value
        passSecurtiy[passNow] = PASS;
        siCV[myLine]->Signal(   );


submission: /home/scf-22/csci350/bin/