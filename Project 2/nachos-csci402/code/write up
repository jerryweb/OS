Title:  Writeup for Project 2, Summer 2015
 Date:  06/25/15
 Group:	Name		Email				SS#
		Jerry Webb	jerryweb@usc.edu	1288504108
		Andrew Lee	lee533@usc.edu		7540910244
		Hao Cui		hcui@usc.edu		1454367516

I. Requirements:
    Implement syscalls:
        Fork: create and run a new thread.
        Exec: create and run a new process.
        Exit: exit the current thread and clean up memory.
        Yield: yield the current thread.
        CreateLock: create a lock stored in the kernel.
        Acquire: acquire a lock stored in the kernel.
        Release: release a lock stored in the kernel.
        DestroyLock: destroy a lock stored in the kernel.
        CreateCondition: create a condition stored in the kernel.
        Wait: wait on a condition stored in the kernel.
        Signal: signal a condition stored in the kernel.
        Broadcast: broadcast on a condition stored in the kernel.
        DestroyCondition: destroy a condition stored in the kernel.
        Printf: print a given string and int parameters to the console.
    Write tests to make sure these syscalls work as intended, both positive and negative.
    Convert the airport from project 1 to use the syscalls and run a test where at least two instances run concurrently.

II. Assumptions:
	The application programmer can count (i.e. they always supply the correct number of characters when passing in a char* string in via syscall).
    Syscalls are always called with the correct type (e.g. no trying to input a char* for a syscall which takes in an int); this should mostly be taken care of by the compiler, but spurious typecasting may or may not be weeded out by error cases depending on the value.

III. Design:
        Fork:
            If the function pointer is null, return. (No way to check for other types of invalid.)
            Read the name in; return if invalid.
            Create a new thread, and set its process to the current process.
            Update the process's thread table.
            Fork the kernel function for the thread:
                Set the program counter of the machine to the function pointer.
                Set the stack register of the machine to the new thread's stack.
                Run the thread.
        Exec:
            Read the filename in; return -1 if invalid.
            Open the file; return -1 if invalid.
            Create a new process with the file handle and a new kernel thread for that process.
            Fork the kernel thread: 
                Initialize registers and run.
            Return the id of the new process (set in the address space constructor).
        Yield:
            Yield the current thread.
        Exit:
            Acquire the process table's lock.
            Get the current process.
            Acquire the current process's thread table's lock.
            Get the current thread's stack location.
            If the process is not the last process:
                If the thread is the last thread in the process:
                    Acquire the lock table's lock.
                    For each lock in the table: if it belongs to the process, destroy it (releasing the lock table's lock in the process), and reacquire the lock table's lock.
                    Release the lock table's lock.
                    Acquire the CV table's lock.
                    For each condition in the table: if it belongs to the process, destroy it (releasing the CV table's lock in the process), and reacquire the CV table's lock.
                    Release the CV table's lock.
                    Clear the process's pages.
                    Remove the process from the process table (releasing the process table's lock in the process).
                Else (if the thread is not the last in the process):
                    Release the process table's lock.
                    Clear the thread's pages.
                Remove the current thread from the process's thread table (releasing the thread table's lock in the process).
                Call finish on the thread.
            Else (if the process is the last process):
                If the thread is the last thread in the process:
                    Acquire the lock table's lock.
                    For each lock in the table: if it belongs to the process, destroy it (releasing the lock table's lock in the process), and reacquire the lock table's lock.
                    Release the lock table's lock.
                    Acquire the CV table's lock.
                    For each condition in the table: if it belongs to the process, destroy it (releasing the CV table's lock in the process), and reacquire the CV table's lock.
                    Release the CV table's lock.
                    Clear the process's pages.
                    Remove the process from the process table (releasing the process table's lock in the process).
                    Halt nachos.
                Else (if the thread is not the last in the process):
                    Release the process table's lock.
                    Clear the thread's pages.
                    Remove the current thread from the process's thread table (releasing the thread table's lock in the process).
                    Call finish on the thread.
        CreateLock:
            Acquire the lock table's lock.
            Read the name in; return -1 if invalid.
            Create a new KernelLock, with the current process as its owner.
            Put the new KernelLock in the lock table (releasing the lock table's lock in the process), and return its id.
        Acquire:
            Acquire the lock table's lock.
            Get the KernelLock from the lock table with the given ID.
            If the KernelLock is null or doesn't have an owner, release the lock table's lock and return.
            If the KernelLock does not belong to the current process, release the lock table's lock and return.
            If the KernelLock's lock is null, release the lock table's lock and return (should never happen).
            Release the lock table's lock.
            Acquire the KernelLock's lock.
        Release:
            Acquire the lock table's lock.
            Get the KernelLock from the lock table with the given ID.
            If the KernelLock is null or doesn't have an owner, release the lock table's lock and return.
            If the KernelLock does not belong to the current process, release the lock table's lock and return.
            If the KernelLock's lock is null, release the lock table's lock and return (should never happen).
            Release the KernelLock's lock.
            Release the lock table's lock.
        DestroyLock:
            Acquire the lock table's lock.
            Get the KernelLock from the lock table with the given ID.
            If the KernelLock is null or doesn't have an owner, release the lock table's lock and return.
            If the KernelLock does not belong to the current process, release the lock table's lock and return.
            If the KernelLock's lock is null, release the lock table's lock and return (should never happen).
            If the KernelLock's delete flag has not been set, set it.
            If the KernelLock's lock has an empty wait queue, no owner, and the delete flag set, set the KernelLock's lock and owner to null.
            Release the lock table's lock.
        CreateCondition:
            Acquire the condition table's lock.
            Read the name in; return -1 if invalid.
            Create a new KernelCondition, with the current process as its owner.
            Put the new KernelCondition in the condition table (releasing the condition table's lock in the process), and return its id.
        Wait:
            Acquire the CV table's lock.
            Get the KernelCondition from the CV table with the given ID.
            If the KernelCondition is null or doesn't have an owner, release the lock table's lock and return.
            Get the KernelCondition's KernelLock from the lock table with the given ID.
            If the KernelLock is null or doesn't have an owner, release the lock table's lock and return.
            If the KernelCondition or KernelLock does not belong to the current process, release the lock table's lock and return.
            If the KernelCondition's condition is null, release the lock table's lock and return (should never happen).
            Release the CV table's lock.
            Wait on the KernelCondition's condition.
        Signal:
            Acquire the CV table's lock.
            Get the KernelCondition from the CV table with the given ID.
            If the KernelCondition is null or doesn't have an owner, release the lock table's lock and return.
            Get the KernelCondition's KernelLock from the lock table with the given ID.
            If the KernelLock is null or doesn't have an owner, release the lock table's lock and return.
            If the KernelCondition or KernelLock does not belong to the current process, release the lock table's lock and return.
            If the KernelCondition's condition is null, release the lock table's lock and return (should never happen).
            Signal the KernelCondition's condition.
            Release the CV table's lock.
        Broadcast:
            Acquire the CV table's lock.
            Get the KernelCondition from the CV table with the given ID.
            If the KernelCondition is null or doesn't have an owner, release the lock table's lock and return.
            Get the KernelCondition's KernelLock from the lock table with the given ID.
            If the KernelLock is null or doesn't have an owner, release the lock table's lock and return.
            If the KernelCondition or KernelLock does not belong to the current process, release the lock table's lock and return.
            If the KernelCondition's condition is null, release the lock table's lock and return (should never happen).
            Broadcast on the KernelCondition's condition.
            Release the CV table's lock.
        DestroyCondition:
            Acquire the CV table's lock.
            Get the KernelCondition from the CV table with the given ID.
            If the KernelCondition is null or doesn't have an owner, release the lock table's lock and return.
            If the KernelCondition does not belong to the current process, release the lock table's lock and return.
            If the KernelCondition's lock is null, release the lock table's lock and return (should never happen).
            If the KernelCondition's delete flag has not been set, set it.
            If the KernelCondition's condition has an empty wait queue and the delete flag set, set the KernelCondition's condition and owner to null.
            Release the CV table's lock.
        Printf:
            Check the number of parameters; if invalid, return.
            Read the input string in; if invalid, return.
            Read in the parameters.
            Find the appropriate print statement and print.
        
        Airport sim:
            Mostly the same as project 1, including locks and CVs. Differences include:
              - Because of lack of NULL definition, added "#define NULL (void*)0".
              - Because of lack of classes in C, uses structs for everything instead.
              - Numbers pre-defined - see part VI, airportTest for more details.
              - Because of lack of heap in nachos, statically declares everything in hard-coded arrays instead of lists. Each new array has its own lock to ensure that it is thread-safe.
              - FIFO for queues is maintained by taking the first element of each array and then moving all others one index up, sticking NULL in the last element.
              - The luggage conveyor that the check-in staff and cargo use was converted to a stack for simplicity (apparently the conveyor belt broke down mid-conversion and they had to pile up the luggage where the cargo handlers could reach it, hence the newest ones getting picked up first).
              - New interaction/break order queues record the order in which different objects interact(Wait, Signal, etc.) or go on break to avoid overwriting of global variables between threads. More specifically, each agent thread function has a pointer to the struct of that type and every other type it interacts with (e.g. Liaison* l and Passenger* p for the liaison function), which get overwritten with every context switch. Therefore, if the liaison wakes up from a wait without its interaction queue, p will point to the most recently awake passenger instead of the value before that specific liaison went to sleep. The interaction queue records the order in which passengers sleep so that the liaisons can interact with the correct passenger. However, this may not work with -rs, because the order in which things go to sleep will not always match the order in which they wake up.

IV. Implementation:

    The structs/enums/functions/whatever else from the .c test files are not included in the sections below, because they're functionally the same from project 1. Also, files with minor modifications which shouldn't affect how the system actually runs (e.g. adding/removing comments or making #include paths more specific) are not listed here.

	+ Files Modified (from project 1, not from base)
        in code:
            Makefile.common
        in code\test:
            Makefile
            start.s
        in code\threads:
            synch.h/.cc
            system.h/.cc
            thread.h/.cc
        in code\userprog:
            addrspace.h/.cc
            exception.cc
            syscall.h
            table.h

	+ Files added
        in code\test:
            airportTest.c
            airportSim.c
            condTest.c
            condTestHelper.c
            execTest.c
            exitTest.c
            forkTest.c
            lockTest.c
            lockTestHelper.c
            printfTest.c

	+ Data Structures added, and the file they were added to.
        Classes: 
            None

        Structs:
            In userprog\exception.cc:
                struct KernelLock
                {
                    Lock* lock;
                    AddrSpace* owner;
                    bool isToBeDeleted;
                };
                struct KernelCondition
                {
                    Condition* condition;
                    AddrSpace* owner;
                    bool isToBeDeleted;
                };

        Enums:
            None

        Arrays, Lists, and Tables:
            In threads\system.h:
                extern Table* lockTable;
                extern Table* CVTable;
                extern Table* processTable;	
                extern BitMap* memMap;
            In userprog\addrspace.cc:
                BitMap* memMap;
            In userprog\exception.cc:
                Table* lockTable;
                Table* cvTable;
                Table* processTable;

	+ Data Structures modified, and the file they were added to.
        In threads\thread.h:
            class thread:
                int threadID;
        In userprog\addrspace.cc:
            class AddrSpace:
                int id;
                Table* threadTable;
        In userprog\table.h:
            class Table:
                int count;
                int maxCount;

	+ Functions added and in which file.
        In threads\synch.h:
            Thread* getOwner();
        In threads\thread.h:
            int getThreadTableLocation();
            void setThreadTableLocation(int loc);
            int getThreadID();
            void setThreadID(int id);
        In userprog\addrspace.h:
            int getNumPages();
            int getID();
            TranslationEntry* getPageTable();
            void setNewPageTable();
            bool getPageTableValidBit(int i);
        In userprog\exception.cc:
            void kernel_function(int vaddr)
            void Fork_Syscall(unsigned int vaddr1, unsigned int vaddr2, int len)
            void exec_thread(int n)
            int Exec_Syscall(unsigned int vaddr, int len)
            void Yield_Syscall()
            void Exit_Syscall(int status)
            void Acquire_Syscall(int id)
            void Release_Syscall(int id)
            void Wait_Syscall(int id, int lockID)
            void Signal_Syscall(int id, int lockID)
            void Broadcast_Syscall(int id, int lockID)
            int CreateLock_Syscall(unsigned int vaddr, int len)
            int CreateCondition_Syscall(unsigned int vaddr, int len)
            void DestroyLock_Syscall(int id)
            void DestroyCondition_Syscall(int id)
            void Printf_Syscall(unsigned int vaddr, int len, int numParams, int params)
            int GetID_Syscall()
            void SetID_Syscall(int id)
        In userprog\syscall.h:
            void Acquire(int id);
            void Release(int id);
            void Wait(int id, int lockID);
            void Signal(int id, int lockID);
            void Broadcast(int id, int lockID);
            int CreateLock(char* name, int len);
            int CreateCondition(char* name, int len);
            void DestroyLock(int id);
            void DestroyCondition(int id);
            void Printf(char* string, int len, int numParams, int params);
            int GetID();
            void SetID(int id);
        In userprog\table.h:
            void lockAcquire();
            void lockRelease();
            int Size();
            int getCount();
            int getMaxCount();

	+ Functions modified and in which file.
        In threads\system.cc:
            void Initialize(int argc, char **argv)
        In userprog\addrspace.cc:
            AddrSpace(OpenFile *executable)
        In userprog\exception.cc:
            void ExceptionHandler(ExceptionType which)
        In userprog\progtest.cc:
            void StartProcess(char *filename)
        In userprog\syscall.h:
            SpaceId Exec(char *name, int len);
            void Fork(void (*func)(), char* name, int len);

V. Testing:
	+ How to test
        nachos -x ../test/forkTest -d z
        nachos -x ../test/execTest -d z
        nachos -x ../test/exitTest -d z
        nachos -x ../test/lockTest -d z
        nachos -x ../test/condTest -d z
        nachos -x ../test/printfTest -d z
        run without "-rs" to ensure proper sequence of events
        "-d z" is necessary to see print statements of the creation of locks and thread/process operations
        
        nachos -x ../test/airportTest

    + Test Output
        I just dumped the full output out of laziness. The final test output may differ, depending on whether we decide to keep or take out (or even add) print statements in the final version.
    
        forkTest:
        
            Fork syscall.
            Thread main: Invalid function pointer
            Fork syscall.
            Thread main: Forking thread Thread A
            Thread Thread A belongs to process 0
            thread table size 2
            Fork syscall.
            Thread main: Forking thread Thread B
            Thread Thread B belongs to process 0
            thread table size 3
            Exit syscall.
            Thread main: Finishing
            Thread Thread A: Entering kernel function
            stack pointer for thread Thread A: 1792
            Thread Thread A: Running
            Printf syscall.
            Fork Test Function for thread A
            Exit syscall.
            Thread Thread A: Finishing
            Thread Thread B: Entering kernel function
            stack pointer for thread Thread B: 2816
            Thread Thread B: Running
            Printf syscall.
            Fork Test Function for thread B
            Exit syscall.
            Thread Thread B: Finishing last process, ending Nachos
            
        execTest:
        
            Exec syscall.
            thread count for process 1: 1
            Printf syscall.
            New process location: 1
            Exec syscall.
            Unable to open file ../test/FooBar
            Exit syscall.
            clearing page 0 for process 0
            clearing page 1 for process 0
            clearing page 2 for process 0
            clearing page 3 for process 0
            clearing page 4 for process 0
            clearing page 5 for process 0
            clearing page 6 for process 0
            clearing page 7 for process 0
            clearing page 8 for process 0
            clearing page 9 for process 0
            clearing page 10 for process 0
            clearing page 11 for process 0
            clearing page 12 for process 0
            calling current thread finish for thread main
            Create syscall.
            Open syscall.
            Write syscall.
            Close syscall.
            Open syscall.
            Read syscall.
            Write syscall.
            testing a write
            Close syscall.
            Exit syscall.
            Thread Kernel thread: Finishing last process, ending Nachos
        
        exitTest:
        
            Fork syscall.
            Thread main: Forking thread Thread A
            Thread Thread A belongs to process 0
            thread table size 2
            Exec syscall.
            thread count for process 1: 1
            Printf syscall.
            New process location: 1
            Exit syscall.
            clearing page 6 for thread  hhh main
            clearing page 7 for thread  hhh main
            clearing page 8 for thread  hhh main
            clearing page 9 for thread  hhh main
            clearing page 10 for thread  hhh main
            clearing page 11 for thread  hhh main
            clearing page 12 for thread  hhh main
            clearing page 13 for thread  hhh main
            calling current thread finish for thread main
            Thread Thread A: Entering kernel function
            stack pointer for thread Thread A: 1792
            Thread Thread A: Running
            Printf syscall.
            Fort Test Fucntion for thread A
            Exit syscall.
            clearing page 0 for process 0
            clearing page 1 for process 0
            clearing page 2 for process 0
            clearing page 3 for process 0
            clearing page 4 for process 0
            clearing page 5 for process 0
            clearing page 14 for process 0
            clearing page 15 for process 0
            clearing page 16 for process 0
            clearing page 17 for process 0
            clearing page 18 for process 0
            clearing page 19 for process 0
            clearing page 20 for process 0
            clearing page 21 for process 0
            calling current thread finish for thread Thread A
            Create syscall.
            Open syscall.
            Write syscall.
            Close syscall.
            Open syscall.
            Read syscall.
            Write syscall.
            testing a write
            Close syscall.
            Exit syscall.
            Thread Kernel thread: Finishing last process, ending Nachos

        lockTest:
        
            Printf syscall.

            TESTING LOCK ID FAILURE CONDITIONS

            CreateLock syscall.
            Thread main: Bad pointer 0 passed to CreateLock, ID -1
            Acquire syscall.
            Thread main: Trying to acquire invalid KernelLock, ID -1
            Release syscall.
            Thread main: Trying to release invalid KernelLock, ID -1
            DestroyLock syscall.
            Thread main: Trying to destroy invalid KernelLock, ID -1
            Acquire syscall.
            Thread main: Trying to acquire invalid KernelLock, ID 1
            Release syscall.
            Thread main: Trying to release invalid KernelLock, ID 1
            DestroyLock syscall.
            Thread main: Trying to destroy invalid KernelLock, ID 1
            CreateLock syscall.
            Thread main: Successfully created Lock, ID 0
            Acquire syscall.
            Thread main: Acquiring Lock, ID 0
            Thread main: Acquired Lock, ID 0
            Release syscall.
            Thread main: Releasing Lock, ID 0
            DestroyLock syscall.
            Thread main: Requesting to destroy Lock, ID 0
            Thread main: Destroying Lock, ID 0
            Acquire syscall.
            Thread main: Trying to acquire invalid KernelLock, ID 0
            Release syscall.
            Thread main: Trying to release invalid KernelLock, ID 0
            DestroyLock syscall.
            Thread main: Trying to destroy invalid KernelLock, ID 0
            Printf syscall.

            TESTING LOCKS ON MULTIPLE THREADS

            CreateLock syscall.
            Thread main: Successfully created Lock, ID 1
            Fork syscall.
            Thread main: Forking thread thread1
            Thread thread1 belongs to process 0
            thread table size 2
            Yield syscall.
            Thread main: Yielding current thread.
            Thread thread1: Entering kernel function
            stack pointer for thread thread1: 2304
            Thread thread1: Running
            Acquire syscall.
            Thread thread1: Acquiring Lock, ID 1
            Thread thread1: Acquired Lock, ID 1
            Yield syscall.
            Thread thread1: Yielding current thread.
            Acquire syscall.
            Thread main: Acquiring Lock, ID 1
            Printf syscall.
            thread1 critical section
            Release syscall.
            Thread thread1: Releasing Lock, ID 1
            DestroyLock syscall.
            Thread thread1: Requesting to destroy Lock, ID 1
            Exit syscall.
            Thread thread1: Finishing
            Thread main: Acquired Lock, ID 1
            Printf syscall.
            main critical section
            Release syscall.
            Thread main: Releasing Lock, ID 1
            DestroyLock syscall.
            Thread main: Destroying Lock, ID 1
            Printf syscall.

            TESTING LOCKS ON MULTIPLE PROCESSES

            CreateLock syscall.
            Thread main: Successfully created Lock, ID 2
            Exec syscall.
            thread count for process 1: 1
            Yield syscall.
            Thread main: Yielding current thread.
            Acquire syscall.
            Thread Kernel thread: Trying to acquire other process's Lock, ID 2
            Release syscall.
            Thread Kernel thread: Trying to release other process's Lock, ID 2
            DestroyLock syscall.
            Thread Kernel thread: Trying to destroy other process's Lock, ID 2
            Exit syscall.
            clearing page 0 for process 1
            clearing page 1 for process 1
            clearing page 2 for process 1
            clearing page 3 for process 1
            clearing page 4 for process 1
            clearing page 5 for process 1
            clearing page 6 for process 1
            clearing page 7 for process 1
            clearing page 8 for process 1
            clearing page 9 for process 1
            clearing page 10 for process 1
            clearing page 11 for process 1
            calling current thread finish for thread Kernel thread
            Exit syscall.
            DestroyLock called by exit
            Thread main: Requesting to destroy Lock, ID 2
            Thread main: Destroying Lock, ID 2
            Thread main: Finishing last process, ending Nachos
        
        condTest:
            Printf syscall.

            TESTING CONDITION ID FAILURE CONDITIONS

            CreateCondition syscall.
            Thread main: Bad pointer 0 passed to CreateCondition, ID -1
            CreateCondition syscall.
            Thread main: Successfully created Condition, ID 0
            Wait syscall.
            Thread main: Trying to wait on invalid KernelCondition, ID -1
            Signal syscall.
            Thread main: Trying to signal invalid KernelCondition, ID -1
            Broadcast syscall.
            Thread main: Trying to broadcast on invalid KernelCondition, ID -1
            DestroyCondition syscall.
            Thread main: Trying to destroy invalid KernelCondition, ID -1
            Wait syscall.
            Thread main: Trying to wait on invalid KernelCondition, ID 1
            Signal syscall.
            Thread main: Trying to signal invalid KernelCondition, ID 1
            Broadcast syscall.
            Thread main: Trying to broadcast on invalid KernelCondition, ID 1
            DestroyCondition syscall.
            Thread main: Trying to destroy invalid KernelCondition, ID 1
            Wait syscall.
            Thread main: Trying to wait using invalid KernelLock, ID -1
            Signal syscall.
            Thread main: Trying to signal using invalid KernelLock, ID -1
            Broadcast syscall.
            Thread main: Trying to broadcast using invalid KernelLock, ID -1
            Printf syscall.

            TESTING CONDITIONS ON MULTIPLE THREADS

            Fork syscall.
            Thread main: Forking thread thread1
            Thread thread1 belongs to process 0
            thread table size 2
            Acquire syscall.
            Thread main: Acquiring Lock, ID 0
            Thread main: Acquired Lock, ID 0
            Wait syscall.
            Thread main: Waiting on Condition, ID 0
            Thread thread1: Entering kernel function
            stack pointer for thread thread1: 2688
            Thread thread1: Running
            Wait syscall.
            Thread thread1: Waiting on Condition, ID 0
            Condition::Wait (thread1): parameter conditionLock (thread1) is not the same as the waitLock (thread1)
            Thread thread1: Waited on Condition, ID 0
            Signal syscall.
            Thread thread1: Signalling Condition, ID 0
            Condition::Wait (thread1): parameter conditionLock (thread1) is not the same as the waitLock (thread1)
            Broadcast syscall.
            Thread thread1: Broadcasting on Condition, ID 0
            Condition::Broadcast (thread1): parameter conditionLock (thread1) is not the same as the waitLock (thread1)
            Acquire syscall.
            Thread thread1: Acquiring Lock, ID 0
            Thread thread1: Acquired Lock, ID 0
            DestroyCondition syscall.
            Thread thread1: Requesting to destroy Condition, ID 0
            Signal syscall.
            Thread thread1: Signalling Condition, ID 0
            Wait syscall.
            Thread thread1: Waiting on Condition, ID 0
            Thread main: Waited on Condition, ID 0
            Fork syscall.
            Thread main: Forking thread thread2
            Thread thread2 belongs to process 0
            thread table size 3
            Acquire syscall.
            Thread main: Acquiring Lock, ID 0
            Thread main: Acquired Lock, ID 0
            Wait syscall.
            Thread main: Waiting on Condition, ID 0
            Thread thread2: Entering kernel function
            stack pointer for thread thread2: 3712
            Thread thread2: Running
            DestroyCondition syscall.
            Broadcast syscall.
            Thread thread2: Broadcasting on Condition, ID 0
            Exit syscall.
            Thread thread2: Finishing
            Thread thread1: Waited on Condition, ID 0
            Exit syscall.
            Thread thread1: Finishing
            Thread main: Waited on Condition, ID 0
            DestroyCondition syscall.
            Thread main: Destroying Condition, ID 0
            Wait syscall.
            Thread main: Trying to wait on invalid KernelCondition, ID 0
            Signal syscall.
            Thread main: Trying to signal invalid KernelCondition, ID 0
            Broadcast syscall.
            Thread main: Trying to broadcast on invalid KernelCondition, ID 0
            DestroyCondition syscall.
            Thread main: Trying to destroy invalid KernelCondition, ID 0
            Printf syscall.

            TESTING CONDITION ON MULTIPLE PROCESSES

            CreateCondition syscall.
            Thread main: Successfully created Condition, ID 1
            Exec syscall.
            thread count for process 1: 1
            Yield syscall.
            Thread main: Yielding current thread.
            Wait syscall.
            Thread Kernel thread: Trying to wait on other process's Condition, ID 1
            Signal syscall.
            Thread Kernel thread: Trying to signal other process's Condition, ID 1
            Broadcast syscall.
            Thread Kernel thread: Trying to broadcast on other process's Condition, ID 1
            DestroyCondition syscall.
            Thread Kernel thread: Trying to destroy other process's Condition, ID 1
            Exit syscall.
            clearing page 0 for process 1
            clearing page 1 for process 1
            clearing page 2 for process 1
            clearing page 3 for process 1
            clearing page 4 for process 1
            clearing page 5 for process 1
            clearing page 6 for process 1
            clearing page 7 for process 1
            clearing page 8 for process 1
            clearing page 9 for process 1
            clearing page 10 for process 1
            clearing page 11 for process 1
            calling current thread finish for thread Kernel thread
            Exit syscall.
            DestroyLock called by exit
            Thread main: Requesting to destroy Lock, ID 0
            Thread main: Destroying Lock, ID 0
            DestroyLock called by exit
            Thread main: Requesting to destroy Lock, ID 1
            Thread main: Destroying Lock, ID 1
            Thread main: Finishing last process, ending Nachos

        airportTest:
            Two sets of standard airport outputs, hopefully (see output guidelines from first project).
            
VI. Discussion:
	+ Experiment expectation.  (What you hope will happen.)
        forkTest:
            First, passes in an invalid function pointer, which fails to fork; then, forks two threads which simply print and exit.
        execTest:
            First, execs testfiles (which tests the file system syscalls), then passes in an invalid file name, which fails to exec. (The failed exec should print before testfiles runs.)
        exitTest:
            Forks a simple print thread, then execs a process (running testfiles). The main thread exits first (>1 process left, >1 thread left), then the forked thread (>1 process left, 1 thread left), then the other process's main thread (1 process left, 1 thread left). 
        lockTest:
            Part 1: Tests the ID failure conditions. Creates a lock with invalid name, which returns -1 for index. Then, tries to use invalid ids -1 and 1 for the calls, which won't work. Then, creates a good lock and tests all calls. Once the lock is deleted, tries to do calls on the again, which fails.
            Part 2: Tests the lock over two threads. Creates a lock, then forks a thread. That thread will acquire, then yield; the main thread will acquire (but not be able to), then the other thread will release, call destroy (which won't do anything but print), and exit. The main thread then releases and destroys.
            Part 3: Tests the lock over two processes. Creates a lock, then execs a process which tries to do syscalls on the first process's lock (which won't work), then exits. The main thread exits, which calls destroy on the lock automatically.
        condTest:
            Part 1: Tests the ID failure conditions. Creates a condition with invalid name, which returns -1 for index. Then, tries to use invalid ids -1 and 1 for the calls, which won't work. Then, creates a good condition and tests all calls with a bad lock, which will work but print an error from the Condition class.
            Part 2: Tests the condition over two threads, using the condition from the previous part. Forks a new thread, then waits on the condition. The new thread tries to call destroy, which doesn't do anything, then signals the condition, waking the main thread up, then waits on the condition. Then, the main thread forks another thread and waits; the second new thread tries to call destroy, which doesn't do anything, then broadcasts, waking both of the other threads up. Both new threads then exit, and the main thread destroys the condition, then tries to do all calls on it again, which fails.
            Part 3: Tests the condition over two processes. Creates a condition, then execs a process which tries to do syscalls on the first process's condition (which won't work), then exits. The main thread exits, which calls destroy on the condition automatically.
        airportTest:
            Execs two airportSim processes, which run a cut-down version of the airport from project 1 with fixed numbers: 3 airlines, 21 passengers (7 per airline), 3 bags per passenger, each 30 lbs, 5 liaisons, 3 check-ins per airline (for a total of 9), 6 cargo handlers, 3 screening officers and security inspectors, and 1 manager.

    + Experiment result.  (What actually happens.)
        All individual tests work as expected.
        airportTest...does not.

	+ Explanation
        One of the more difficult tasks was to convert the original airport simulation into system executable code. Since C does not have a heap or the ability to use classes, a large portion of the logic used in our airport had to be changed. This mean that all of our lists, classes, dynamically allocated variables, etc. were incompatible. We decided to use structs as a replacement for the classes as they allowed for a degree of personalization of data. This also meant that dynamic data structures were also unusable, therefore, more primitive data structures such as arrays had to be used and adapted. Our project 1 design of the airport is not opitimal for conversion to a heapless architecture. This is one of the reasons why part 3 presented the most challenge, and also why the -rs function produces race conditions. 

VIII. Miscellaneous:
    Security for project2 part unfinished
    
    We changed NumPhysPages in machine.h to 10000.
    
    For threads folder:
    We updated the project 1 airport in the threads folder to run smoothly under -rs test, we tested -manager -rs x, x from 1 to 100 without errors and all classes function correctly.(-manager is our full simulation for aiport)
    What we have done for the Optimization:
    We optimized passenger, liaison,check-in, screen officer, security inspecotr and manager class, the major design changes we made are:
    1. Doing double wait and double signal for all the basic interactions between different classes.
    2. Optimize the data requesting calls made from manager class, instead of using conditions we use locks to simplify the structure, and these eliminate some potential synchronization traps.
    3. Optimize the ending condition for the classes mentioned above.
      
    
    
    
    
